{
  "slug": "qa-unit-testing",
  "title": "Юнит-тестирование с Vitest и Testing Library",
  "description": "Практическое руководство по написанию юнит-тестов для функций и React-компонентов с использованием Vitest и Testing Library.",
  "topicSlug": "qa",
  "date": "2026-02-05",
  "readTime": "10 мин",
  "tags": ["QA", "Vitest", "Testing Library", "Юнит-тесты", "React"],
  "content": "\n## Что такое Vitest?\n\n**Vitest** — современный фреймворк для тестирования, разработанный командой Vite. Он быстрый, поддерживает TypeScript из коробки и совместим с API Jest.\n\n### Установка\n\n```bash\nnpm install -D vitest @testing-library/react @testing-library/jest-dom jsdom\n```\n\n### Конфигурация\n\n```typescript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: './src/test-setup.ts',\n  },\n});\n```\n\n```typescript\n// src/test-setup.ts\nimport '@testing-library/jest-dom';\n```\n\n## Тестирование функций\n\nНачнём с простых утилитарных функций — это самая лёгкая точка входа.\n\n### Базовый пример\n\n```typescript\n// utils.ts\nexport function capitalize(str: string): string {\n  if (!str) return '';\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function sum(a: number, b: number): number {\n  return a + b;\n}\n```\n\n```typescript\n// utils.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { capitalize, sum } from './utils';\n\ndescribe('capitalize', () => {\n  it('делает первую букву заглавной', () => {\n    expect(capitalize('hello')).toBe('Hello');\n  });\n\n  it('возвращает пустую строку для пустого ввода', () => {\n    expect(capitalize('')).toBe('');\n  });\n\n  it('не изменяет уже заглавную букву', () => {\n    expect(capitalize('Hello')).toBe('Hello');\n  });\n});\n\ndescribe('sum', () => {\n  it('складывает два положительных числа', () => {\n    expect(sum(2, 3)).toBe(5);\n  });\n\n  it('работает с отрицательными числами', () => {\n    expect(sum(-1, 1)).toBe(0);\n  });\n});\n```\n\n### Основные матчеры (matchers)\n\n```typescript\n// Равенство\nexpect(value).toBe(42);           // строгое ===\nexpect(obj).toEqual({ a: 1 });    // глубокое сравнение\n\n// Правдивость\nexpect(value).toBeTruthy();\nexpect(value).toBeFalsy();\nexpect(value).toBeNull();\nexpect(value).toBeUndefined();\n\n// Числа\nexpect(value).toBeGreaterThan(3);\nexpect(value).toBeLessThanOrEqual(10);\nexpect(0.1 + 0.2).toBeCloseTo(0.3);\n\n// Строки\nexpect(str).toContain('hello');\nexpect(str).toMatch(/regex/);\n\n// Массивы\nexpect(arr).toHaveLength(3);\nexpect(arr).toContain('item');\n\n// Исключения\nexpect(() => fn()).toThrow();\nexpect(() => fn()).toThrow('сообщение');\n```\n\n## Тестирование React-компонентов\n\n### React Testing Library\n\n**Философия:** тестируйте так, как пользователь взаимодействует с компонентом.\n\n```tsx\n// Button.tsx\ninterface ButtonProps {\n  label: string;\n  onClick: () => void;\n  disabled?: boolean;\n}\n\nexport function Button({ label, onClick, disabled }: ButtonProps) {\n  return (\n    <button onClick={onClick} disabled={disabled}>\n      {label}\n    </button>\n  );\n}\n```\n\n```tsx\n// Button.test.tsx\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { describe, it, expect, vi } from 'vitest';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  it('отображает текст кнопки', () => {\n    render(<Button label=\"Нажми\" onClick={() => {}} />);\n    expect(screen.getByText('Нажми')).toBeInTheDocument();\n  });\n\n  it('вызывает onClick при клике', async () => {\n    const handleClick = vi.fn();\n    render(<Button label=\"Нажми\" onClick={handleClick} />);\n    \n    await userEvent.click(screen.getByText('Нажми'));\n    expect(handleClick).toHaveBeenCalledOnce();\n  });\n\n  it('не вызывает onClick когда disabled', async () => {\n    const handleClick = vi.fn();\n    render(<Button label=\"Нажми\" onClick={handleClick} disabled />);\n    \n    await userEvent.click(screen.getByText('Нажми'));\n    expect(handleClick).not.toHaveBeenCalled();\n  });\n});\n```\n\n### Запросы (Queries)\n\nTesting Library предлагает приоритет запросов по доступности:\n\n```typescript\n// 1. Доступные запросы (предпочтительные)\nscreen.getByRole('button', { name: 'Отправить' });\nscreen.getByLabelText('Email');\nscreen.getByPlaceholderText('Поиск...');\nscreen.getByText('Привет мир');\n\n// 2. Семантические запросы\nscreen.getByAltText('Логотип');\nscreen.getByTitle('Закрыть');\n\n// 3. Test ID (крайний случай)\nscreen.getByTestId('custom-element');\n```\n\n### Варианты запросов\n\n| Префикс | Поведение |\n|---------|----------|\n| `getBy` | Кидает ошибку, если не найден |\n| `queryBy` | Возвращает `null`, если не найден |\n| `findBy` | Возвращает `Promise`, ждёт появления |\n\n## Моки и шпионы\n\n### vi.fn() — мок-функции\n\n```typescript\nconst mockFn = vi.fn();\nmockFn('arg1');\n\nexpect(mockFn).toHaveBeenCalled();\nexpect(mockFn).toHaveBeenCalledWith('arg1');\nexpect(mockFn).toHaveBeenCalledTimes(1);\n```\n\n### vi.mock() — мок модулей\n\n```typescript\nimport { vi } from 'vitest';\nimport { fetchUser } from './api';\n\nvi.mock('./api', () => ({\n  fetchUser: vi.fn(() => \n    Promise.resolve({ name: 'Иван', age: 25 })\n  ),\n}));\n\nit('отображает данные пользователя', async () => {\n  render(<UserProfile id=\"1\" />);\n  \n  expect(await screen.findByText('Иван')).toBeInTheDocument();\n  expect(fetchUser).toHaveBeenCalledWith('1');\n});\n```\n\n## Запуск тестов\n\n```bash\n# Запуск всех тестов\nnpx vitest run\n\n# Watch-режим\nnpx vitest\n\n# Один файл\nnpx vitest run src/utils.test.ts\n\n# С покрытием\nnpx vitest run --coverage\n\n# Фильтр по имени\nnpx vitest run -t \"capitalize\"\n```\n\n## Лучшие практики\n\n1. **Один `expect` — один аспект** — каждый тест проверяет одну вещь\n2. **AAA-паттерн** — Arrange (подготовка), Act (действие), Assert (проверка)\n3. **Описательные имена** — `it('показывает ошибку при пустом email')`, а не `it('test 1')`\n4. **Избегайте деталей реализации** — тестируйте поведение, а не внутреннюю структуру\n5. **Изолированные тесты** — используйте `beforeEach` для сброса состояния\n\n```typescript\ndescribe('LoginForm', () => {\n  // AAA-паттерн\n  it('показывает ошибку при невалидном email', async () => {\n    // Arrange\n    render(<LoginForm />);\n    \n    // Act\n    await userEvent.type(\n      screen.getByLabelText('Email'), \n      'невалидный'\n    );\n    await userEvent.click(screen.getByText('Войти'));\n    \n    // Assert\n    expect(\n      screen.getByText('Введите корректный email')\n    ).toBeInTheDocument();\n  });\n});\n```\n\nВ следующей статье мы рассмотрим E2E-тестирование с Playwright для проверки полных пользовательских сценариев.\n    "
}
